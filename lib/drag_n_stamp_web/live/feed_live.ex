defmodule DragNStampWeb.FeedLive do
  use DragNStampWeb, :live_view
  alias DragNStamp.{Repo, Timestamp}
  alias DragNStamp.SEO.PagePath
  import Ecto.Query
  require Logger

  @topic "timestamps"
  @per_page 10
  @status_failure_window_minutes 240
  @status_processing_window_minutes 90

  def mount(params, _session, socket) do
    if connected?(socket) do
      Phoenix.PubSub.subscribe(DragNStamp.PubSub, @topic)
    end

    page = String.to_integer(params["page"] || "1")

    timestamps =
      Timestamp
      |> order_by(desc: :inserted_at)
      |> Repo.all()

    {:ok,
     assign(socket,
       timestamps: timestamps,
       filter_submitter: "",
       filter_channel: "",
       sort_by: "newest",
       page: page,
       per_page: @per_page,
       page_title: "YouTube Timestamp Feed | Recently Created Video Chapters",
       page_description:
         "Browse the latest YouTube video timestamps generated by StampBot. Find chapter markers and key moments from videos across all channels, updated in real-time."
     )}
  end

  def handle_info({:timestamp_created, timestamp}, socket) do
    Logger.info("Received new timestamp via PubSub: #{timestamp.id}")

    updated_timestamps = [timestamp | socket.assigns.timestamps]

    {:noreply,
     socket
     |> assign(:timestamps, sort_timestamps(updated_timestamps, socket.assigns.sort_by))
     |> put_flash(:info, "New timestamp received from #{timestamp.submitter_username}!")}
  end

  def handle_info({:timestamp_updated, timestamp}, socket) do
    timestamps = socket.assigns.timestamps

    updated_list =
      if Enum.any?(timestamps, &(&1.id == timestamp.id)) do
        Enum.map(timestamps, fn t -> if t.id == timestamp.id, do: timestamp, else: t end)
      else
        [timestamp | timestamps]
      end

    {:noreply,
     assign(socket, :timestamps, sort_timestamps(updated_list, socket.assigns.sort_by))}
  end

  def handle_event("filter_changed", params, socket) do
    {:noreply,
     assign(socket,
       filter_submitter: params["submitter"] || "",
       filter_channel: params["channel"] || "",
       sort_by: params["sort"] || "newest",
       page: 1
     )}
  end

  def handle_event("change_page", %{"page" => page}, socket) do
    {:noreply, assign(socket, page: String.to_integer(page))}
  end

  def handle_event("retry_comment", %{"id" => id}, socket) do
    case Repo.get(Timestamp, id) do
      nil ->
        {:noreply, socket}

      ts ->
        if ts.youtube_comment_status == :succeeded || not is_nil(ts.youtube_comment_external_id) do
          {:noreply, socket}
        else
          result = DragNStamp.Commenter.post_for_timestamp(ts)

          updated_ts =
            case result do
              {:ok, updated, _info} -> updated
              _ -> ts
            end

          updated_list =
            Enum.map(socket.assigns.timestamps, fn t ->
              if t.id == updated_ts.id, do: updated_ts, else: t
            end)

          {:noreply, assign(socket, :timestamps, updated_list)}
        end
    end
  end

  def handle_event("retry_submission", %{"id" => id}, socket) do
    case Repo.get(Timestamp, id) do
      nil ->
        {:noreply, socket}

      %Timestamp{} = ts ->
        if retry_allowed?(ts) do
          now = DateTime.utc_now()
          ctx = ts.processing_context || %{}
          updated_ctx =
            ctx
            |> Map.put("manual_retry_used", true)
            |> Map.put("manual_retry_last_at", now)

          changes = %{processing_context: updated_ctx}

          {:ok, persisted} = Repo.update(Timestamp.changeset(ts, changes))

          # Kick off a background reprocessing using the existing pipeline
          Task.start(fn -> DragNStampWeb.ApiController.reprocess_timestamp(persisted) end)

          # Optimistic UI update: mark local copy as processing and with retry set
          optimistic = %{
            persisted
            | processing_status: :processing,
              processing_error: nil
          }

          updated_list =
            Enum.map(socket.assigns.timestamps, fn t ->
              if t.id == optimistic.id, do: optimistic, else: t
            end)

          {:noreply,
           socket
           |> assign(:timestamps, updated_list)
           |> put_flash(:info, "Retry started for this submission.")}
        else
          {:noreply, put_flash(socket, :error, "Retry not allowed for this submission.")}
        end
    end
  end

  defp sort_timestamps(timestamps, sort_by) do
    case sort_by do
      "newest" -> Enum.sort_by(timestamps, & &1.inserted_at, {:desc, NaiveDateTime})
      "oldest" -> Enum.sort_by(timestamps, & &1.inserted_at, {:asc, NaiveDateTime})
      _ -> timestamps
    end
  end

  defp filtered_timestamps(assigns) do
    assigns.timestamps
    |> Enum.filter(fn t ->
      (assigns.filter_submitter == "" or t.submitter_username == assigns.filter_submitter) and
        (assigns.filter_channel == "" or t.channel_name == assigns.filter_channel)
    end)
    |> sort_timestamps(assigns.sort_by)
  end

  defp unique_submitters(timestamps) do
    timestamps
    |> Enum.map(& &1.submitter_username)
    |> Enum.uniq()
    |> Enum.sort()
  end

  defp unique_channels(timestamps) do
    timestamps
    |> Enum.map(& &1.channel_name)
    |> Enum.uniq()
    |> Enum.sort()
  end

  defp paginated_timestamps(assigns) do
    filtered = filtered_timestamps(assigns)
    offset = (assigns.page - 1) * assigns.per_page

    filtered
    |> Enum.slice(offset, assigns.per_page)
  end

  defp total_pages(assigns) do
    total = length(filtered_timestamps(assigns))
    div(total + assigns.per_page - 1, assigns.per_page)
  end

  defp seo_page_path(%Timestamp{id: nil}), do: nil

  defp seo_page_path(%Timestamp{} = timestamp) do
    PagePath.page_path(timestamp)
  end

  defp overall_status(assigns) do
    timestamps = assigns.timestamps

    case latest_recent_failure(timestamps) do
      nil ->
        case recent_processing_count(timestamps) do
          0 -> :healthy
          count -> {:processing, count}
        end

      failure ->
        {:issue, failure}
    end
  end

  defp latest_recent_failure(timestamps) do
    timestamps
    |> Enum.filter(&recent_failure?/1)
    |> Enum.sort_by(&reference_time/1, {:desc, NaiveDateTime})
    |> List.first()
  end

  defp recent_failure?(%Timestamp{} = timestamp) do
    timestamp.processing_status == :failed and
      not unsupported_failure?(timestamp) and
      recent?(reference_time(timestamp), @status_failure_window_minutes)
  end

  defp unsupported_failure?(%Timestamp{processing_error: msg}) when is_binary(msg) do
    String.starts_with?(msg, "[unsupported:")
  end

  defp unsupported_failure?(_), do: false

  defp recent_processing_count(timestamps) do
    timestamps
    |> Enum.filter(fn t ->
      t.processing_status == :processing and
        recent?(reference_time(t), @status_processing_window_minutes)
    end)
    |> length()
  end

  defp reference_time(%Timestamp{} = timestamp) do
    timestamp.updated_at || timestamp.inserted_at
  end

  defp has_distilled_content?(%Timestamp{distilled_content: content}) when is_binary(content) do
    String.trim(content) != ""
  end

  defp has_distilled_content?(_), do: false

  defp content_contains_unwatched?(%Timestamp{content: content}) when is_binary(content) do
    String.contains?(content, "0:00 UNWATCHED")
  end

  defp content_contains_unwatched?(_), do: false

  defp manual_retry_used?(%Timestamp{processing_context: ctx}) when is_map(ctx) do
    case ctx do
      %{} = m ->
        (Map.get(m, "manual_retry_used") == true) or
          (Map.get(m, "manual_retry_count", 0) |> Kernel.>=(1))
      _ -> false
    end
  end

  defp manual_retry_used?(_), do: false

  defp retry_allowed?(%Timestamp{} = ts) do
    content_contains_unwatched?(ts) and not manual_retry_used?(ts)
  end

  defp recent?(nil, _window_minutes), do: false

  defp recent?(%NaiveDateTime{} = dt, window_minutes) when is_integer(window_minutes) do
    NaiveDateTime.diff(NaiveDateTime.utc_now(), dt, :minute) <= window_minutes
  end

  defp recent?(%DateTime{} = dt, window_minutes) when is_integer(window_minutes) do
    recent?(DateTime.to_naive(dt), window_minutes)
  end

  defp recent?(_, _), do: false

  defp format_inserted_at(%Timestamp{} = timestamp) do
    format_datetime(timestamp.inserted_at)
  end

  defp format_datetime(nil), do: "â€”"

  defp format_datetime(%DateTime{} = dt), do: format_datetime(DateTime.to_naive(dt))

  defp format_datetime(%NaiveDateTime{} = ndt) do
    Calendar.strftime(ndt, "%b %d, %Y %I:%M %p UTC")
  rescue
    _ -> NaiveDateTime.to_string(ndt)
  end

  defp format_datetime(other), do: to_string(other)

  defp iso_string(nil), do: nil

  defp iso_string(%NaiveDateTime{} = ndt), do: NaiveDateTime.to_iso8601(ndt) <> "Z"

  defp iso_string(%DateTime{} = dt), do: DateTime.to_iso8601(dt)

  defp iso_string(other), do: to_string(other)

  defp status_reference_time(%Timestamp{} = timestamp), do: reference_time(timestamp)

  defp pluralize(1, singular, _plural), do: singular
  defp pluralize(_, _singular, plural), do: plural
end
